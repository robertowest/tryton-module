from trytond.model import ModelView, ModelSQL, fields, Unique
from trytond.pyson import Eval

__all__ = ['Sacerdote']

STATES    = {'readonly': ~Eval('active'),}
DEPENDS   = ['active']
SEPARATOR = ' / '


class Sacerdote(ModelSQL, ModelView):
    "Sacerdote"
    __name__ = 'arzo.sacerdote'

    apellido    = fields.Char('Apellido', required=True, states=STATES, depends=DEPENDS)
    nombre      = fields.Char('Nombre', required=True, states=STATES, depends=DEPENDS)
    dni         = fields.Char('DNI', states=STATES, depends=DEPENDS)
    fnacimiento = fields.Date('Fec. Nacimiento', states=_STATES, depends=_DEPENDS)
    fordenacion = fields.Date('Fec. Ordenacion', states=_STATES, depends=_DEPENDS)
    protocolo   = fields.Char('Protocolo ', states=STATES, depends=DEPENDS)
    active      = fields.Boolean('Activo')

    @classmethod
    def __setup__(cls):
        super(Sacerdote, cls).__setup__()
        t = cls.__table__()
        cls._sql_constraints = [('unique_apellido_nombre', Unique(t, t.apellido, t.nombre),
                                 'El nombre del sacerdote debe ser unico.'),
                               ]
        cls._error_messages.update({'wrong_apellido':
                                    ('Apellido invalido: No puedo usar "%s".' % SEPARATOR),
                                   })
        cls._order.insert(0, ('apellido', 'ASC'))

    @staticmethod
    def default_active():
        return True

    @classmethod
    def validate(cls, sacerdotes):
        super(Sacerdote, cls).validate(sacerdotes)
        cls.check_recursion(sacerdotes, rec_name='apellido')
        for sacerdote in sacerdotes:
            sacerdote.check_name()

    def check_name(self):
        if SEPARATOR in self.apellido:
            self.raise_user_error('wrong_apellido', (self.apellido,))

    def get_rec_name(self, name):
        if self.parent:
            return self.parent.get_rec_name(apellido) + SEPARATOR + self.apellido
        return self.apellido

    @classmethod
    def search_rec_name(cls, apellido, clause):
        if isinstance(clause[2], basestring):
            values = clause[2].split(SEPARATOR)
            values.reverse()
            domain = []
            field = 'apellido'
            for apellido in values:
                domain.append((field, clause[1], apellido))
                field = 'parent.' + field
            return domain
        # TODO Handle list
        return [('apellido',) + tuple(clause[1:])]
